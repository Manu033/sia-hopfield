import numpy as np
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS

# ===========================
# Utilidades
# ===========================


def to_col_vec(x):
    x = np.array(x, dtype=int).reshape(-1)
    assert set(np.unique(x)).issubset({-1, 1}), "Vector debe tener valores -1 o 1"
    return x


# Funcion de activación
def sign(z):
    # sgn(0) = 1 por conveniencia; puede ajustarse si se desea sgn(0)=0
    return np.where(z >= 0, 1, -1)


def energy(W, x):
    # Energía de Hopfield (sin sesgo): E(x) = -1/2 x^T W x
    return float(-0.5 * x.T @ W @ x)


# ===========================
# Clase Hopfield
# ===========================


class Hopfield:
    def __init__(self, n):
        self.n = n
        self.W = np.zeros((n, n), dtype=int)
        self.learned = {}  # label -> pattern (np.array)

    def reset(self):
        self.W[:] = 0
        self.learned.clear()

    def hebbian_train(self, patterns):
        W = np.zeros((self.n, self.n), dtype=float)
        for p in patterns:
            p = to_col_vec(p)
            W += np.outer(p, p)
        np.fill_diagonal(W, 0)
        W /= len(patterns)  # ← normaliza por cantidad de patrones
        self.W = W
        return self.W

    def store_labeled(self, labeled_patterns):
        """labeled_patterns: lista de dicts {"label":str, "vector":[...]}"""
        for item in labeled_patterns:
            lab = item["label"].strip().upper()
            vec = to_col_vec(item["vector"])  # valida {-1,1}
            if vec.size != self.n:
                raise ValueError("Dimensión incorrecta del vector")
            self.learned[lab] = vec
        # re-entrenar con todos los almacenados
        allp = list(self.learned.values())
        if allp:
            self.hebbian_train(allp)
        else:
            self.W[:] = 0

    def recognize(self, x0, max_steps=20, synchronous=False):
        """Reconocimiento con actualización asíncrona y energía monitoreada."""
        x = to_col_vec(x0)
        steps, energies = [], []

        for k in range(max_steps):
            prev_x = x.copy()

            if synchronous:
                h = self.W @ x
                s = np.where(h > 0, 1, np.where(h < 0, -1, x))  # conserva estado si h=0
                x = s
            else:
                # actualización asíncrona (garantiza descenso de energía)
                for i in np.random.permutation(self.n):
                    h_i = np.dot(self.W[i, :], x)
                    if h_i > 0:
                        x[i] = 1
                    elif h_i < 0:
                        x[i] = -1
                    # si h_i == 0, deja x[i] igual

            energies.append(energy(self.W, x))
            steps.append(
                {
                    "k": k + 1,
                    "h": (self.W @ x).tolist(),  # vuelve a incluir h
                    "s": x.tolist(),
                }
            )

            if np.array_equal(x, prev_x):
                break  # alcanzó equilibrio

        # buscar coincidencia
        match_label = None
        for lab, p in self.learned.items():
            if np.array_equal(p, x):
                match_label = lab
                break

        # distancia mínima por diagnóstico
        best_label, best_dist = None, None
        for lab, p in self.learned.items():
            d = int(np.sum(p != x))
            if best_dist is None or d < best_dist:
                best_label, best_dist = lab, d

        return {
            "final": x.tolist(),
            "match": match_label,
            "nearest_label": best_label,
            "nearest_hamming": best_dist,
            "steps": steps,
            "energies": energies,
            "energy_final": energies[-1],
        }


# ===========================
# Datos de ejemplo (>=10 letras)
# Convención: 1 = negro, -1 = blanco; recorrido por filas (4x4 = 16)
# Estas son plantillas simples tipo bloque para A, C, E, F, H, I, L, O, P, T, U, V
# (Podés editar/expandir)
# ===========================

LETTER_9x9 = {
    "A": [
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "C": [
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "E": [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "H": [
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "L": [
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "O": [
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "T": [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "V": [
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "X": [
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
    "Z": [
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
    ],
}


# ===========================
# Servidor Flask
# ===========================

app = Flask(__name__, static_folder="static", static_url_path="/")
CORS(app)

N = 81
HOP = Hopfield(N)

# Cargar por defecto algunas letras
HOP.store_labeled([{"label": k, "vector": v} for k, v in LETTER_9x9.items()])


@app.get("/")
def root():
    return send_from_directory("static", "index.html")


@app.get("/api/W")
def api_W():
    return jsonify({"W": HOP.W.tolist()})


@app.get("/api/letters")
def api_letters():
    return jsonify(
        {
            "n": HOP.n,
            "labels": list(HOP.learned.keys()),
            "patterns": {k: v.tolist() for k, v in HOP.learned.items()},
        }
    )


@app.post("/api/reset")
def api_reset():
    HOP.reset()
    return jsonify({"ok": True})


@app.post("/api/store")
def api_store():
    data = request.get_json(force=True)
    items = data.get("patterns", [])
    HOP.store_labeled(items)
    return jsonify({"ok": True, "labels": list(HOP.learned.keys())})


@app.post("/api/train_default")
def api_train_default():
    HOP.reset()
    HOP.store_labeled([{"label": k, "vector": v} for k, v in LETTER_9x9.items()])
    return jsonify({"ok": True, "labels": list(HOP.learned.keys())})


@app.post("/api/recognize")
def api_recognize():
    data = request.get_json(force=True)
    vec = data.get("vector")
    max_steps = int(data.get("max_steps", 20))
    result = HOP.recognize(vec, max_steps=max_steps)
    result["energy_final"] = energy(HOP.W, np.array(result["final"]))
    return jsonify(result)


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000, debug=True)
